---
title: ERC-20 Token Info
description: Read ERC-20 metadata and balances using EspaceClient and ERC20_ABI from @cfxdevkit/core.
---

import { Callout } from 'nextra/components'

# ERC-20 Token Info

Read token metadata (name, symbol, decimals, total supply) and holder balances using `EspaceClient.readContract()` with the built-in `ERC20_ABI`.

<Callout type="tip">
Change `TOKEN` to any ERC-20 address on testnet. The default is **WCFX** (Wrapped CFX on testnet), a contract that always has liquidity.
</Callout>

<Playground
  file="/index.ts"
  files={{
    "/index.ts": `import { EspaceClient, ERC20_ABI, formatUnits } from '@cfxdevkit/core'
import { NETWORK } from './network-config'

// ── Config ──────────────────────────────────────────────────
// WCFX on testnet — always-live ERC-20, safe to query
const TOKEN  = '0x2ed3dddae5b2f321af0806181fbfa6d049be47d8'
const HOLDER = '0x0000000000000000000000000000000000000001'

// ── Client ──────────────────────────────────────────────────
const client = new EspaceClient({
  chainId: NETWORK.chainId,
  rpcUrl:  NETWORK.rpcUrl,
})

async function main() {
  console.log('Token:  ', TOKEN)
  console.log('Network:', NETWORK.rpcUrl)
  console.log()

  // Batch-read all ERC-20 metadata in parallel
  // ERC20_ABI is exported from @cfxdevkit/core and covers all standard methods
  const [name, symbol, decimals, totalSupply] = await Promise.all([
    client.readContract({ address: TOKEN, abi: ERC20_ABI, functionName: 'name'        }),
    client.readContract({ address: TOKEN, abi: ERC20_ABI, functionName: 'symbol'      }),
    client.readContract({ address: TOKEN, abi: ERC20_ABI, functionName: 'decimals'    }),
    client.readContract({ address: TOKEN, abi: ERC20_ABI, functionName: 'totalSupply' }),
  ])

  console.log('Name:         ', name)
  console.log('Symbol:       ', symbol)
  console.log('Decimals:     ', decimals)
  console.log('Total supply: ', formatUnits(totalSupply, decimals), symbol)
  console.log()

  // Single holder balance
  const balance = await client.readContract({
    address: TOKEN,
    abi: ERC20_ABI,
    functionName: 'balanceOf',
    args: [HOLDER],
  })
  console.log('Balance of', HOLDER)
  console.log(' ', formatUnits(balance, decimals), symbol)
  console.log()

  // getTokenBalance() is a convenience shortcut for balanceOf
  const shortcut = await client.getTokenBalance(HOLDER, TOKEN)
  console.log('getTokenBalance() raw:', shortcut, 'wei')
  console.log('             formatted:', formatUnits(BigInt(shortcut), decimals), symbol)
  console.log()
  console.log('\\u2713 Done')
}

main().catch(console.error)
`
  }}
  showConsole
/>

---

## How it works

1. `ERC20_ABI` is exported from `@cfxdevkit/core` and covers all standard ERC-20 methods (name, symbol, decimals, totalSupply, balanceOf, allowance, transfer, approve, transferFrom).
2. `client.readContract({ address, abi, functionName, args })` is a thin wrapper around viem's `publicClient.readContract`.
3. `Promise.all([...])` runs all four metadata reads in a single burst for efficiency.
4. `client.getTokenBalance(holder, token)` is a convenience shortcut that returns the raw BigInt balance as a string; use `formatUnits` to convert.

```typescript
// Production import
import { EspaceClient, ERC20_ABI, formatUnits } from '@cfxdevkit/core'

const client = new EspaceClient({ chainId: 71, rpcUrl: 'https://evmtestnet.confluxrpc.com' })
const [name, symbol, decimals] = await Promise.all([
  client.readContract({ address: TOKEN, abi: ERC20_ABI, functionName: 'name' }),
  client.readContract({ address: TOKEN, abi: ERC20_ABI, functionName: 'symbol' }),
  client.readContract({ address: TOKEN, abi: ERC20_ABI, functionName: 'decimals' }),
])
```
