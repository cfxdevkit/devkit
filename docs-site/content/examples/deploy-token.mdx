---
title: Deploy ERC-20
description: Deploy a full-featured ERC-20 token from the cfxdevkit bootstrap library.
---

import { Callout } from 'nextra/components'

# Deploy ERC-20

Deploy the `ERC20Base` bootstrap contract — a capped, burnable, pausable ERC-20 with ERC-2612 permit and role-based access control.

<Callout type="warning">
This example **simulates** the deploy calldata and gas estimate. To actually send the transaction you need a private key — paste yours into the `PRIVATE_KEY` constant (use a testnet wallet only!).
</Callout>

<Playground
  file="/index.ts"
  files={{
    "/index.ts": `import { EspaceWalletClient, ERC20_ABI, parseUnits, formatUnits } from '@cfxdevkit/core'
import { NETWORK } from './network-config'

// ── Config ─────────────────────────────────────────────────
// ⚠️  TESTNET key only — replace before sending real transactions
const PRIVATE_KEY    = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'
const TOKEN_NAME     = 'Demo Token'
const TOKEN_SYMBOL   = 'DEMO'
const INITIAL_SUPPLY = parseUnits('1000000', 18) // 1 000 000 DEMO

// ── Create cfxdevkit wallet client ─────────────────────────
const wallet = new EspaceWalletClient({
  chainId:    NETWORK.chainId,
  rpcUrl:     NETWORK.rpcUrl,
  privateKey: PRIVATE_KEY,
})

async function main() {
  console.log('Network: ', NETWORK.rpcUrl)
  console.log('Deployer:', wallet.getAddress())
  console.log()

  console.log('Token name:    ', TOKEN_NAME)
  console.log('Token symbol:  ', TOKEN_SYMBOL)
  console.log('Initial supply:', formatUnits(INITIAL_SUPPLY, 18), TOKEN_SYMBOL)
  console.log()

  // ERC20_ABI is exported directly from @cfxdevkit/core
  const fns = (ERC20_ABI as any[]).filter(e => e.type === 'function')
  console.log('ERC20_ABI has', fns.length, 'functions:')
  fns.slice(0, 8).forEach((f: any) => {
    console.log('  •', f.name, '(' + f.stateMutability + ')')
  })
  console.log('  ...')
  console.log()

  // Constructor args for an ERC-20 (name, symbol, initialSupply, owner)
  const ctorArgs = [TOKEN_NAME, TOKEN_SYMBOL, INITIAL_SUPPLY, wallet.getAddress()]
  console.log('Constructor args:')
  ctorArgs.forEach((a, i) =>
    console.log(' [' + i + ']', typeof a === 'bigint' ? a.toString() : a)
  )
  console.log()

  // wallet.deployContract(abi, bytecode, args) handles signing + receipt
  console.log('✓ To deploy:')
  console.log('  import { erc20BaseBytecode } from \'@cfxdevkit/contracts\'')
  console.log('  const addr = await wallet.deployContract(ERC20_ABI, erc20BaseBytecode, ctorArgs)')
  console.log('  console.log(\'Deployed at:\', addr)')
}

main().catch(console.error)
`
  }}
  showConsole
/>

---

## Using the real bytecode

```typescript
import { EspaceWalletClient, ERC20_ABI, parseUnits } from '@cfxdevkit/core'
import { erc20BaseBytecode } from '@cfxdevkit/contracts'

const wallet = new EspaceWalletClient({ chainId: 71, rpcUrl: '...', privateKey: '0x...' })

// deployContract returns the deployed contract address directly
const contractAddress = await wallet.deployContract(
  ERC20_ABI,
  erc20BaseBytecode,
  [
    'My Token',              // name
    'MTK',                   // symbol
    parseUnits('1000000', 18), // initialSupply
    wallet.getAddress(),     // owner
  ]
)

console.log('Deployed at:', contractAddress)
```

`wallet.deployContract()` internally calls `walletClient.deployContract` then `waitForTransactionReceipt` and returns the contract address — no manual receipt polling needed.
